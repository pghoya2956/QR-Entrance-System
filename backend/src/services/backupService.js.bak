const cron = require('node-cron');
const path = require('path');
const fs = require('fs').promises;
const { createReadStream, createWriteStream } = require('fs');
const { createGzip } = require('zlib');
const { pipeline } = require('stream').promises;

class BackupService {
  constructor() {
    this.dbService = require('./dbService');
    this.backupDir = path.join(__dirname, '../data/backups');
    this.dbPath = path.join(__dirname, '../data/qr-entrance.db');
    this.isRunning = false;
    this.lastBackupStatus = null;
    this.backupHistory = [];
  }

  async ensureBackupDirectory() {
    try {
      await fs.mkdir(this.backupDir, { recursive: true });
    } catch (error) {
      console.error('ë°±ì—… ë””ë ‰í† ë¦¬ ìƒì„± ì˜¤ë¥˜:', error);
      throw error;
    }
  }

  async createBackup() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const backupFileName = `backup-${timestamp}.db`;
    const backupPath = path.join(this.backupDir, backupFileName);
    const gzipPath = `${backupPath}.gz`;

    try {
      console.log(`ğŸ”„ ë°±ì—… ì‹œì‘: ${backupFileName}`);
      
      // SQLite ë°±ì—… API ì‚¬ìš©
      await this.dbService.backup(backupPath);
      
      // ë°±ì—… íŒŒì¼ ì••ì¶•
      console.log('ğŸ“¦ ë°±ì—… íŒŒì¼ ì••ì¶• ì¤‘...');
      await pipeline(
        createReadStream(backupPath),
        createGzip({ level: 9 }),
        createWriteStream(gzipPath)
      );
      
      // ì›ë³¸ ë°±ì—… íŒŒì¼ ì‚­ì œ (ì••ì¶• íŒŒì¼ë§Œ ìœ ì§€)
      await fs.unlink(backupPath);
      
      // íŒŒì¼ í¬ê¸° í™•ì¸
      const stats = await fs.stat(gzipPath);
      const fileSizeInMB = (stats.size / (1024 * 1024)).toFixed(2);
      
      // ë°±ì—… ê¸°ë¡ ì €ì¥
      const backupRecord = {
        time: new Date().toISOString(),
        filePath: gzipPath,
        fileSize: stats.size,
        sizeInMB: fileSizeInMB,
        status: 'success'
      };
      
      this.backupHistory.push(backupRecord);
      this.lastBackupStatus = backupRecord;
      
      // ë°ì´í„°ë² ì´ìŠ¤ì— ë°±ì—… ê¸°ë¡ ì €ì¥
      await this.saveBackupRecord(backupRecord);
      
      console.log(`âœ… ë°±ì—… ì™„ë£Œ: ${backupFileName}.gz (${fileSizeInMB} MB)`);
      
      // ì˜¤ë˜ëœ ë°±ì—… ì‚­ì œ
      await this.cleanOldBackups();
      
      return backupRecord;
      
    } catch (error) {
      console.error('âŒ ë°±ì—… ì‹¤íŒ¨:', error);
      
      const failureRecord = {
        time: new Date().toISOString(),
        filePath: gzipPath,
        status: 'failed',
        error: error.message
      };
      
      this.backupHistory.push(failureRecord);
      this.lastBackupStatus = failureRecord;
      
      // ì‹¤íŒ¨ ê¸°ë¡ë„ ì €ì¥
      await this.saveBackupRecord(failureRecord);
      
      throw error;
    }
  }

  async saveBackupRecord(record) {
    try {
      const db = this.dbService.db;
      const stmt = db.prepare(`
        INSERT INTO backup_history (backup_time, file_path, file_size, status, error_message)
        VALUES (?, ?, ?, ?, ?)
      `);
      
      stmt.run(
        record.time,
        record.filePath,
        record.fileSize || null,
        record.status,
        record.error || null
      );
    } catch (error) {
      console.error('ë°±ì—… ê¸°ë¡ ì €ì¥ ì˜¤ë¥˜:', error);
    }
  }

  async cleanOldBackups() {
    try {
      const files = await fs.readdir(this.backupDir);
      const backupFiles = files.filter(f => f.startsWith('backup-') && f.endsWith('.db.gz'));
      
      // ë‚ ì§œìˆœ ì •ë ¬ (ìµœì‹ ìˆœ)
      backupFiles.sort().reverse();
      
      // 30ì¼ ì´ìƒ ëœ ë°±ì—… íŒŒì¼ ì‚­ì œ
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      for (const file of backupFiles) {
        // íŒŒì¼ëª…ì—ì„œ ë‚ ì§œ ì¶”ì¶œ (backup-YYYY-MM-DD-HH-mm-ss.db.gz)
        const dateMatch = file.match(/backup-(\d{4}-\d{2}-\d{2})/);
        if (dateMatch) {
          const fileDate = new Date(dateMatch[1]);
          
          if (fileDate < thirtyDaysAgo) {
            const filePath = path.join(this.backupDir, file);
            await fs.unlink(filePath);
            console.log(`ğŸ—‘ï¸  ì˜¤ë˜ëœ ë°±ì—… ì‚­ì œ: ${file}`);
          }
        }
      }
      
      // ìµœê·¼ 30ê°œë§Œ ìœ ì§€ (ì¶”ê°€ ì•ˆì „ì¥ì¹˜)
      if (backupFiles.length > 30) {
        const filesToDelete = backupFiles.slice(30);
        for (const file of filesToDelete) {
          const filePath = path.join(this.backupDir, file);
          await fs.unlink(filePath);
          console.log(`ğŸ—‘ï¸  ì´ˆê³¼ ë°±ì—… ì‚­ì œ: ${file}`);
        }
      }
      
    } catch (error) {
      console.error('ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬ ì˜¤ë¥˜:', error);
    }
  }

  async restoreBackup(backupFileName) {
    const backupPath = path.join(this.backupDir, backupFileName);
    
    try {
      // .gz íŒŒì¼ì¸ ê²½ìš° ì••ì¶• í•´ì œ
      if (backupFileName.endsWith('.gz')) {
        const tempPath = backupPath.replace('.gz', '');
        
        await pipeline(
          createReadStream(backupPath),
          createGunzip(),
          createWriteStream(tempPath)
        );
        
        // í˜„ì¬ DB ë°±ì—…
        const currentBackup = path.join(this.backupDir, `before-restore-${Date.now()}.db`);
        await fs.copyFile(this.dbPath, currentBackup);
        
        // ë³µì›
        await fs.copyFile(tempPath, this.dbPath);
        
        // ì„ì‹œ íŒŒì¼ ì‚­ì œ
        await fs.unlink(tempPath);
        
        console.log(`âœ… ë°±ì—… ë³µì› ì™„ë£Œ: ${backupFileName}`);
      }
    } catch (error) {
      console.error('ë°±ì—… ë³µì› ì˜¤ë¥˜:', error);
      throw error;
    }
  }

  start() {
    if (this.isRunning) {
      console.log('âš ï¸  ë°±ì—… ì„œë¹„ìŠ¤ê°€ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.');
      return;
    }

    // ë°±ì—… ë””ë ‰í† ë¦¬ í™•ì¸
    this.ensureBackupDirectory().then(() => {
      // ë§¤ì¼ ìƒˆë²½ 2ì‹œì— ë°±ì—… ì‹¤í–‰
      this.cronJob = cron.schedule('0 2 * * *', async () => {
        console.log('â° ì˜ˆì•½ëœ ë°±ì—… ì‘ì—… ì‹œì‘...');
        try {
          await this.createBackup();
        } catch (error) {
          console.error('ì˜ˆì•½ëœ ë°±ì—… ì‹¤íŒ¨:', error);
        }
      });

      this.isRunning = true;
      console.log('âœ… ë°±ì—… ì„œë¹„ìŠ¤ ì‹œì‘ë¨ (ë§¤ì¼ ìƒˆë²½ 2ì‹œ ì‹¤í–‰)');
      
      // ì‹œì‘ ì‹œ ì¦‰ì‹œ ë°±ì—… (ì„ íƒì‚¬í•­)
      if (process.env.BACKUP_ON_START === 'true') {
        console.log('ğŸš€ ì´ˆê¸° ë°±ì—… ì‹¤í–‰...');
        this.createBackup().catch(console.error);
      }
    }).catch(error => {
      console.error('ë°±ì—… ì„œë¹„ìŠ¤ ì‹œì‘ ì‹¤íŒ¨:', error);
    });
  }

  stop() {
    if (this.cronJob) {
      this.cronJob.stop();
      this.isRunning = false;
      console.log('â¹ï¸  ë°±ì—… ì„œë¹„ìŠ¤ ì¤‘ì§€ë¨');
    }
  }

  // ë°±ì—… ìƒíƒœ ì¡°íšŒ
  getStatus() {
    return {
      isRunning: this.isRunning,
      lastBackup: this.lastBackupStatus,
      recentBackups: this.backupHistory.slice(-10), // ìµœê·¼ 10ê°œ
      nextBackup: this.isRunning ? 'ë§¤ì¼ ìƒˆë²½ 2ì‹œ' : null
    };
  }

  // ë°±ì—… ëª©ë¡ ì¡°íšŒ
  async listBackups() {
    try {
      const files = await fs.readdir(this.backupDir);
      const backupFiles = files.filter(f => f.startsWith('backup-') && f.endsWith('.db.gz'));
      
      const backups = await Promise.all(
        backupFiles.map(async (file) => {
          const filePath = path.join(this.backupDir, file);
          const stats = await fs.stat(filePath);
          
          return {
            fileName: file,
            size: stats.size,
            sizeInMB: (stats.size / (1024 * 1024)).toFixed(2),
            created: stats.mtime
          };
        })
      );
      
      // ìµœì‹ ìˆœ ì •ë ¬
      backups.sort((a, b) => b.created - a.created);
      
      return backups;
    } catch (error) {
      console.error('ë°±ì—… ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
      return [];
    }
  }
}

module.exports = new BackupService();